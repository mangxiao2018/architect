# 高并发场景下强一致预算/库存扣减方案

## 场景描述

对于预算扣减/库存扣减类场景，我们需要根据业务对已有预算/库存做减法，拿发券的场景来举例：

- 需要满足不同的发券需求，运营可配置预算扣减业务
- 每次请求扣减一定数量的金额，比如发10元券给用户
- 需要保持强一致，计划中的预算金额尽可能全部发出去，但不能多发，多发会有资金损失，所以需要有强一致的保证

本文介绍的方案还可以作为秒杀类业务中的一部分

## 概述

对于预算的扣减需求，可以用2条简单的sql来理解：

- 第一条SQL，记录流水，流水有幂等的作用，还可用于做对账，SQL简化如下：

```text
insert into budget_log (biz_no, budget_code) values (#{bizNo}, #{budget_code})
```

其中biz_no表示一次扣减的唯一标识，budget_code是一个预算计划的唯一标识

- 第二条SQL用于做真正的扣减：

```mysql
update budget set amount = amount - #{amt} where budget_code = #{budgetCode} and amount >= #{amt}
```

但是如果对并发的要求是百级别，仅仅依靠这两条sql或许可以满足需求，但是想要达到数十万以上的并发支撑，这样是远远不够的。

我曾经使用的库(全库能支持6k的tps)能支持到300次扣减，数据库资源发挥不出来。为什么会出现这种情况呢？6k的tps只能发挥出600tps的能力（300次流水插入+300次预算扣减），因为数据库在执行扣减sql时，会加上行锁，所有的扣减都会在此排队

## 有何方案

很多人会使用缓存解决问题，使用缓存后，并发往往能达到要求，但是缓存的另一个问题在于无法保持强一致，且缓存有宕机的风险，宕机后相关数据丢失，对于有强一致需求的场景，使用缓存并不合适，需要考虑基于数据库的方案，

前面说过，扣减sql有行锁导致并发量无法提高，那么我们可以将数据进行拆分，将一行数据拆分成多行，分布在不同的表上，可更进一步使用分库分表的方式提高并发量。

## 基于分库分表的方案

### 分表方案

按照我使用的DB的能力，DB能支持6k的tps，一次预算扣减需要一次写流水和一次扣减操作，那么可以算出，DB每秒可支持3000次预算扣减业务，而在单行上只能支持300次扣减业务，我们可以分10个表，将单行转变为10行

假如有100万预算，分10个表，每个表10万，扣减方案如下图：



![img](https://pic4.zhimg.com/80/v2-6d513ab82840c66e339bcbfe482a57e7_720w.jpg)


分表扣减

- 使用单个流水表，多个数据表的方式，因为流水表不是瓶颈，瓶颈在数据表的行锁上，所以流水表不需要分表
- 表路由组件可通过biz_no做hash，分配到不同的分表上做扣减

通过分表的方案后，能支撑秒级3000次的扣减业务，但是这样还不够，如果想要支撑数十万，依然远远不够。

## 分表+分库方案

通过前面的计算，我们知道，分表后，可将单个数据库的性能发挥到极限，想要再进一步提高支持的并发量，可以再加上分库的方式，使用分库分表的方案，单库秒级只能支撑3000次扣减业务，那么如果分100库，则秒级可支撑30万次扣减业务，如下图：





![img](https://pic4.zhimg.com/80/v2-64c705ca1aa4f57d46a2efd8a11470cb_720w.jpg)


分库分表方案

还是假设有100万预算，当我们使用100库1000表后，单行转变成了1000行，处理能力可扩大1000倍，每个表1000预算

需要注意的是：

- 在分库分表的方案下，流水表也需要分表，但是每个库一个分表即可，假如是100库，则流水表使用百库百表即可
- 同一次扣减业务，记流水表必须要和执行扣减发生在同一个分库中，需要通过事务保证一致性

## 问题与风险分析

通过分库分表的方式，我们确实可以达到非常高的并发量的支持，但是如果结合实际情况，我们会发现以下问题：

### 解决流量不均的问题

如果流量不均，那么每容易出现某些表很快就扣完了，有些表扣的比较慢，这样导致系统整体容量降低

我们可以通过按需分配的方式解决这个问题，我们将每个表上的一行数据称为一个分桶，我们增加总桶的概念，初始时，预算都在总桶中，然后依次给每个分桶分配少量的预算，比如100（具体的分配金额可根据实际场景确定），那么初始分配后，每个分桶100，1000个分桶一共10万，总桶中还有90万，当一个分桶扣完后，立即向总桶申请一定的预算，这样可以保证分桶中的预算大体上是按流量分配的，方案如下图：





![img](https://pic1.zhimg.com/80/v2-6fcbf3afbaf8721fedfb79f16a85a408_720w.jpg)


预算申请

### 解决库被打挂的风险

当总桶无预算时，预算申请都会失败，而当预算申请失败后，某些库可能会出现无预算可扣的情况，在这种场景下，如果换到有预算的库做预算的扣减，那么就可能会出现库被打挂的风险，举个例子：
假设业务上有10万的tps，100库平均每个库1000，当总桶无预算可申请，其中的99个库慢慢的扣完后，10万的tps会打到剩下的一个有预算的库上，这个库肯定无法承受秒级10万的扣减业务

如何解决这个问题呢？在前面描述的按需申请预算的基础上做一个限制，分库路由规则中，如果业务被分到了无预算可扣减的库上，则返回扣减失败，给调用方返回预算已扣完，因为流量大体上是均衡的，所以这样做的问题并不大

## 分库分表的作用

本文介绍的方案是基于分库分表的，脱离我们这个方法，最后聊一聊分库分表的作用，根据经验，我认为分库分表可解决以下问题：

- 数据量大导致单表/单库效率低，通过分库分表可解决数据量大的问题
- 单库/单表能力不足，支撑不了业务量，使用分库分表的方式提高系统能力（本文介绍的方案属于这一种）
- 容错，降低数据库故障给业务带来的影响，比如分100库，当其中一个库不可用时（软硬件升级导致的故障等因素），只影响1%

所以，在数据量并不大的情况下，也是有分库分表的场景和必要性的

------

已经预设了前提，强一致性和超高并发，这种场景只能硬抗。

不像几十万人秒杀百来件商品可以层层过滤，最终流到数据库的请求很少，博主预设的场景下，数据库实实在在的就是要承担几十万的并发。这种场景下，分表分库的是我能想到的唯一的水平扩展方案。

我最近也在思考高并发扣减库存的问题, 你的思路很赞,给了我很多启发. 关于解决流量不均衡的问题, 我想到另外一个思路,你看看是否靠谱:



1.除了总桶的概念, 其余设计保持不变

2.设计一个分桶状态表, 记录分桶所在库名,表名和状态. 状态只记录是否还有库存剩余

3.所有库存一次性分配到各个分桶, 每个分桶的状态都为有库存

4.需要扣减库存时,从分桶状态表中读取有库存的分桶列表, 随机选择一个,进行扣减.若失败,则修改此分桶的状态为无库存. 并随机选择另一个分桶进行扣减. 根据业务情况, 可以如此循环几次, 或者直到扣减库存成功

5.分桶状态表的使用场景符合写少读多, 数据库可使用一主多从的方案解决. 另外还可以加上缓存增加读的并发.



可能遇到的问题:

在极端情况下, 可能分桶状态表的写操作有瞬间的峰值, 如秒杀场景. 可能造成分桶状态更新延迟, 触发很多重复修改分桶状态为无库存的请求.进一步增加状态表的写压力. 可以考虑如下方案解决:

1.把有库存的分桶列表存储到Redis的哈希表中, 库名和表名组成一个字符串作为key. 当分桶无库存时, 删除对应的key. 按Redis的性能单机支持10k QPS的写并发应该没有问题, 也就是高并发下可以支持10k个分桶管理. 一般业务足够用了.

2.若先不考虑具体业务场景, 纯技术讨论, 进一步增加分桶状态修改的写并发(单机Redis无法负载), 可以考虑对分桶进行分群组, 例如9k个分桶一个群组, 每个群组的分桶状态分别由不同的Redis记录. 扣减库存时, 随机挑选一个群组进行操作. 如此,理论上通过增加机器, 线性的增加系统负载能力.

分布式锁也可以锁在商品上，单个商品串行，多个商品并行。

更好的办法是，redis本来就是单线程的，所以可以考虑把“检查库存-扣减库存-返回结果”的动作写成lua脚本去调用，一个调用就能原子化地操作库存了



------

如果redis 宕机了，怎么办呀

redis本身也可以做高可用，但是由于redis并不是“同步”的主从备份，所以在主从切换的瞬间仍然有可能丢失一些数据，这可能就需要事后人为介入，把数据库里的库存同步到redis里了。
也可以把redis看成是一个取号器，就是执行了这样的lua后返回值是true(代表可以成功扣减的)的，再由服务端去数据库执行真正的扣减。为了保证redis与数据库的同步，还需要在数据库里预写一笔日志(数据库更新成功后可以在一个数据库日志里把日志状态更新成已完成)，这样在redis成功扣减后，更新数据库失败时(比如掉电了)，因为这笔日志的关系，还可以有一个后台补偿机制把库存还给redis

那这样的话，数据库写的瓶颈不还是依然存在吗？

并不，这个方案主要解决类似秒杀这样的场景，也就是注定大多数写入的尝试是失败的，用取号器限流以后，写入量就是有限的。如果你还是担心的话，可以把取号器成功取号以后的逻辑用消息队列来处理，这样并发写入量完全是你可以控制的

理解一下你的意思，就是写入数据库的操作是异步的，扣减库存还是相当于发生在redis；那就假如redis宕机，此时的数据库中的库存就不是真实的库存了，因为redis的数据可能还没同步到数据库中

是，但不准确，redis本身可以做高可用，故障后可以故障转移，问题是redis主从同步不是“同步”的，是异步的，所以转移后可能会丢一部分操作(丢可能一秒内的操作)，所以故障转移后可能需要人工介入，核对一下数据库和redis的库存

emm,顺着你的意思说啊，那假设这样一种情况，redis主库减了一条库存，发送给消息队列通知数据库减库存，此时redis主库挂了，从库还没来得及同步刚才减库存的记录；那么这时需要人工介入，把数据库的库存同步到redis中，这段时间，上游发来的减库存请求统统失败

并不。redis主成功扣减，还没来得及同步到从，但可能已经写入消息队列(因为redis的主从同步是异步的)，这时啪叽主挂了，那么从提升为主之后，消息队列的消息被消费了以后，数据库和redis就对不上了。
又或者，redis成功扣减，但还没来得及写入消息队列，这时应用服务挂了，那么又会产生一个差异。
发生比如掉电断网这样的故障后可能需要人工介入，来同步一下两边的库存